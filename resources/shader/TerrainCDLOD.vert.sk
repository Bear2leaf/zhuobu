#version 300 es 
layout(location = 0) in vec3 a_position;
layout(location = 1) in vec3 a_color;
layout(location = 7) in int a_edge;
layout(location = 8) in vec2 a_offset;
layout(location = 9) in float a_scale;

uniform float u_resolution;
uniform sampler2D u_texture7;
uniform vec3 u_eye;

uniform Model {
  mat4 u_world;
};
uniform Camera {
  mat4 u_viewInverse;
  mat4 u_projection;
};
out vec3 v_color;
out vec2 v_position;
out vec4 v_vertexPosition;
out float v_scale;

const int EDGE_MORPH_TOP = 1;
const int EDGE_MORPH_LEFT = 2;
const int EDGE_MORPH_BOTTOM = 4;
const int EDGE_MORPH_RIGHT = 8;

const float MORPH_REGION = 0.3f;
// Poor man's bitwise &
bool edgePresent(int edge) {
    int e = a_edge / edge;
    return 2 * (e / 2) != e;
}

// At the edges of tiles morph the vertices, if they are joining onto a higher layer
float calculateMorph(vec2 p) {
    float morphFactor = 0.0f;
    if(edgePresent(EDGE_MORPH_TOP) && p.y >= 1.0f - MORPH_REGION) {
        float m = 1.0f - clamp((1.0f - p.y) / MORPH_REGION, 0.0f, 1.0f);
        morphFactor = max(m, morphFactor);
    }
    if(edgePresent(EDGE_MORPH_LEFT) && p.x <= MORPH_REGION) {
        float m = 1.0f - clamp(p.x / MORPH_REGION, 0.0f, 1.0f);
        morphFactor = max(m, morphFactor);
    }
    if(edgePresent(EDGE_MORPH_BOTTOM) && p.y <= MORPH_REGION) {
        float m = 1.0f - clamp(p.y / MORPH_REGION, 0.0f, 1.0f);
        morphFactor = max(m, morphFactor);
    }
    if(edgePresent(EDGE_MORPH_RIGHT) && p.x >= 1.0f - MORPH_REGION) {
        float m = 1.0f - clamp((1.0f - p.x) / MORPH_REGION, 0.0f, 1.0f);
        morphFactor = max(m, morphFactor);
    }

    return morphFactor;
}

// 01 // morphs input vertex uv from high to low detailed mesh position
// 02 // - gridPos: normalized [0, 1] .xy grid position of the source vertex
// 03 // - vertex: vertex.xy components in the world space
// 04 // - morphK: morph value
// 05
// 06 const float2 g_gridDim = float2( 64, 64 );
// 07
// 08 float2 morphVertex( float2 gridPos, float2 vertex, float morphK )
// 09 {
// 10 float2 fracPart = frac( gridPos.xy * g_gridDim.xy * 0.5 ) * 2.0 / g_gridDim.xy;
// 11 return vertex.xy - fracPart * g_quadScale.xy * morphK;
// 12 }

vec2 calculateNoMorphNeighbour(vec2 position, float morphK) {
    vec2 fraction = fract(a_position.xz * u_resolution * 0.5f) * 2.0f / u_resolution;
    return position - fraction * morphK * a_scale;
}


void main() {
    vec2 origin = a_position.xz;
    // Morph between zoom layers
    float morphK = calculateMorph(origin);
    vec4 worldOffset = inverse(u_world) * vec4(u_eye.x, 0.0f, u_eye.z, 1.0f);
    vec2 position = origin * a_scale + a_offset + worldOffset.xz;
    position = calculateNoMorphNeighbour(position, morphK);
    position = clamp(position, -0.9f, 0.9f);
    float height = texture(u_texture7, position * 0.5f + 0.5f).r;
    height = height * 2.0f - 1.0f;
    // float height = textureLod(u_texture7, position * 0.5f + 0.5f, log2(1.0f / a_scale)).r - 0.5f;
    // float height = 0.0f;
    v_color = a_color;
    v_position = position;
    v_scale = a_scale;
    gl_Position = u_projection * u_viewInverse * u_world * vec4(position.x, height, position.y, 1.0f);
    v_vertexPosition = u_world * vec4(position.x, height, position.y, 1.0f);

}
#version 300 es 
layout(location = 0) in vec3 a_position;
layout(location = 1) in vec3 a_color;

uniform float u_scale;
uniform int u_edge;
uniform float u_resolution;
uniform vec2 u_offset;
uniform sampler2D u_texture7;
uniform mat4 u_model;
uniform vec4 u_perspective;
uniform vec3 u_eye;
uniform vec3 u_target;
uniform vec3 u_up;

out vec3 v_color;
out vec2 v_position;

const int EDGE_MORPH_TOP = 1;
const int EDGE_MORPH_LEFT = 2;
const int EDGE_MORPH_BOTTOM = 4;
const int EDGE_MORPH_RIGHT = 8;

const float MORPH_REGION = 0.3f;
// Poor man's bitwise &
bool edgePresent(int edge) {
    int e = u_edge / edge;
    return 2 * (e / 2) != e;
}

// At the edges of tiles morph the vertices, if they are joining onto a higher layer
float calculateMorph(vec2 p) {
    float morphFactor = 0.0f;
    if(edgePresent(EDGE_MORPH_TOP) && p.y >= 1.0f - MORPH_REGION) {
        float m = 1.0f - clamp((1.0f - p.y) / MORPH_REGION, 0.0f, 1.0f);
        morphFactor = max(m, morphFactor);
    }
    if(edgePresent(EDGE_MORPH_LEFT) && p.x <= MORPH_REGION) {
        float m = 1.0f - clamp(p.x / MORPH_REGION, 0.0f, 1.0f);
        morphFactor = max(m, morphFactor);
    }
    if(edgePresent(EDGE_MORPH_BOTTOM) && p.y <= MORPH_REGION) {
        float m = 1.0f - clamp(p.y / MORPH_REGION, 0.0f, 1.0f);
        morphFactor = max(m, morphFactor);
    }
    if(edgePresent(EDGE_MORPH_RIGHT) && p.x >= 1.0f - MORPH_REGION) {
        float m = 1.0f - clamp((1.0f - p.x) / MORPH_REGION, 0.0f, 1.0f);
        morphFactor = max(m, morphFactor);
    }

    return morphFactor;
}

// 01 // morphs input vertex uv from high to low detailed mesh position
// 02 // - gridPos: normalized [0, 1] .xy grid position of the source vertex
// 03 // - vertex: vertex.xy components in the world space
// 04 // - morphK: morph value
// 05
// 06 const float2 g_gridDim = float2( 64, 64 );
// 07
// 08 float2 morphVertex( float2 gridPos, float2 vertex, float morphK )
// 09 {
// 10 float2 fracPart = frac( gridPos.xy * g_gridDim.xy * 0.5 ) * 2.0 / g_gridDim.xy;
// 11 return vertex.xy - fracPart * g_quadScale.xy * morphK;
// 12 }

vec2 calculateNoMorphNeighbour(vec2 position, float morphK) {
    vec2 fraction = fract(a_position.xz * u_resolution * 0.5f) * 2.0f / u_resolution;
    return position - fraction * morphK * u_scale;
}

mat4 projection() {
    float fov = u_perspective.x;
    float aspect = u_perspective.y;
    float near = u_perspective.z;
    float far = u_perspective.w;
    float f = 1.0f / tan(fov / 2.0f);
    return mat4(f / aspect, 0.0f, 0.0f, 0.0f, 0.0f, f, 0.0f, 0.0f, 0.0f, 0.0f, (far + near) / (near - far), -1.0f, 0.0f, 0.0f, (2.0f * far * near) / (near - far), 0.0f);

}
mat4 modelView() {
    vec3 f = normalize(u_target - u_eye);
    vec3 r = normalize(cross(f, u_up));
    vec3 u = cross(r, f);
    return mat4(r.x, u.x, -f.x, 0.0f, r.y, u.y, -f.y, 0.0f, r.z, u.z, -f.z, 0.0f, -dot(r, u_eye), -dot(u, u_eye), dot(f, u_eye), 1.0f);
}

void main() {
    vec2 origin = a_position.xz;
    // Morph between zoom layers
    float morphK = calculateMorph(origin);
    vec4 worldOffset = inverse(u_model) * vec4(u_eye.x, 0.0f, u_eye.z, 1.0f);
    vec2 position = origin * u_scale + u_offset + worldOffset.xz;
    position = calculateNoMorphNeighbour(position, morphK);
    position = clamp(position, -0.9f, 0.9f);
    float height = texture(u_texture7, position * 0.5f + 0.5f).r * 2.0f - 1.0f;
    // float height = textureLod(u_texture7, position * 0.5f + 0.5f, log2(1.0f / u_scale)).r - 0.5f;
    // float height = 0.0f;
    v_color = a_color;
    v_position = position;
    gl_Position = projection() * modelView() * u_model * vec4(position.x, height, position.y, 1.0f);

}